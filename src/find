#include <stdlib.h>
#include <ncurses.h>
#include <signal.h>
#include "engine.h"
#include "obstacle.h"
#include "util.h"

volatile sig_atomic_t engine_is_game_over = 0;

static Player  player;
static WINDOW *pad;

/* Obstacle & difficulty state */
static float speed_pxps;
static float spawn_timer, spawn_next;
static float time_accum;

void engine_init(void)
{
    int term_h, term_w; getmaxyx(stdscr, term_h, term_w);
    pad = newpad(term_h, term_w);

    player = (Player){ .x = 5, .y = term_h - 2, .vy = 0, .w = 3, .h = 2 };

    speed_pxps  = OB_SPEED_START;
    spawn_timer = 0.f;
    spawn_next  = 1.f;
    time_accum  = 0.f;

    ob_init();
}

void engine_on_jump(void)
{
    if (player.vy == 0) player.vy = JUMP_VELOCITY;
}

void engine_update(float dt, int term_w)
{
    int term_h; getmaxyx(stdscr, term_h, term_w);

    /* Player physics */
    player.vy += GRAVITY_PPS2 * dt;
    player.y  += player.vy * dt;
    if (player.y >= term_h - 2){ player.y = term_h - 2; player.vy = 0; }

    /* Obstacles */
    spawn_timer += dt;
    if (spawn_timer >= spawn_next){
        ob_spawn(term_w - 1, term_h - 1);
        spawn_timer = 0.f;
        spawn_next  = randf(OB_SPAWN_MIN, OB_SPAWN_MAX);
    }
    ob_update(dt, speed_pxps);

    /* Difficulty scaling */
    time_accum += dt;
    if (time_accum >= OB_SPEED_INC_EVERY){
        speed_pxps += OB_SPEED_INC_STEP;
        time_accum  = 0.f;
    }

    /* Collision */
    if (ob_collide(player.x, player.y - 1, player.w, player.h))
        engine_is_game_over = 1;
}

void engine_render(void)
{
    int term_h, term_w; getmaxyx(stdscr, term_h, term_w);
    werase(pad);

    ob_draw(pad);
    mvwaddstr(pad, (int)player.y - 1, (int)player.x, "(•ω•)");

    prefresh(pad, 0, 0, 0, 0, term_h - 1, term_w - 1);
}
#define _POSIX_C_SOURCE 199309L
#include <ncurses.h>
#include <mqueue.h>
#include <unistd.h>
#include <fcntl.h>
#include "input.h"

void input_child_loop(void)
{
    initscr(); cbreak(); noecho(); curs_set(0);
    nodelay(stdscr, TRUE);

    mqd_t mq = mq_open(MQ_NAME, O_WRONLY);
    InputMsg msg;

    while (1){
        int ch = getch();
        if (ch == ERR){ usleep(8000); continue; }
        if (ch == 'q'){ msg.key = 'q'; mq_send(mq, (char*)&msg, sizeof msg, 0); break; }
        if (ch == ' '){ msg.key = ' '; mq_send(mq, (char*)&msg, sizeof msg, 0); }
    }
    endwin();
    mq_close(mq);
}
#include <signal.h>
#include <sys/time.h>
#include <unistd.h>
#include <mqueue.h>
#include <ncurses.h>
#include "engine.h"
#include "input.h"

static volatile sig_atomic_t g_tick = 0;
static void tick_handler(int s){ (void)s; g_tick = 1; }

/* Consume MQ and forward to engine */
static void consume_input(mqd_t mq)
{
    InputMsg m;
    while (mq_receive(mq, (char*)&m, sizeof m, NULL) != -1){
        if (m.key == ' ') engine_on_jump();
        if (m.key == 'q') engine_is_game_over = 1;
    }
}

int main(void)
{
    /* Open MQ */
    struct mq_attr attr = { .mq_maxmsg = 8, .mq_msgsize = sizeof(InputMsg) };
    mqd_t mq = mq_open(MQ_NAME, O_CREAT | O_RDWR, 0600, &attr);

    /* Fork child for keyboard */
    pid_t child = fork();
    if (child == 0){ input_child_loop(); return 0; }

    /* Parent: init curses */
    initscr(); cbreak(); noecho(); curs_set(0);

    /* Timer */
    struct itimerval iv = {
        .it_interval = { .tv_sec = 0, .tv_usec = FRAME_USEC },
        .it_value    = { .tv_sec = 0, .tv_usec = FRAME_USEC }
    };
    signal(SIGALRM, tick_handler);
    setitimer(ITIMER_REAL, &iv, NULL);

    engine_init();

    while (!engine_is_game_over){
        pause();                     /* wait for SIGALRM */
        g_tick = 0;
        consume_input(mq);
        engine_update(FRAME_DT, COLS);
        engine_render();
    }

    endwin();
    kill(child, SIGTERM);
    mq_close(mq); mq_unlink(MQ_NAME);
    return 0;
}
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include "obstacle.h"
#include "util.h"

static Obstacle obs[OB_MAX];
static int head = 0, tail = 0;

static inline int ob_count(void){ return (tail + OB_MAX - head) % OB_MAX; }

void ob_init(void){ head = tail = 0; memset(obs, 0, sizeof obs); }

void ob_spawn(float start_x, float ground_y)
{
    if (((tail + 1) % OB_MAX) == head) return; /* full; drop */
    obs[tail] = (Obstacle){ .x = start_x, .y = ground_y - 1 }; /* top-left */
    tail = (tail + 1) % OB_MAX;
}

void ob_update(float dt, float speed)
{
    for(int i = head; i != tail; i = (i + 1) % OB_MAX)
        obs[i].x -= speed * dt;

    while (ob_count() && obs[head].x + OB_WIDTH < 0)
        head = (head + 1) % OB_MAX;
}

bool ob_collide(float px, float py, int pw, int ph)
{
    for(int i = head; i != tail; i = (i + 1) % OB_MAX){
        Obstacle *o = &obs[i];
        bool hit = !(px+pw <= o->x || o->x+OB_WIDTH <= px ||
                py+ph <= o->y || o->y+OB_HEIGHT <= py);
        if (hit) return true;
    }
    return false;
}

void ob_draw(WINDOW *w)
{
    for(int i = head; i != tail; i = (i + 1) % OB_MAX){
        Obstacle *o = &obs[i];
        for(int dy = 0; dy < OB_HEIGHT; ++dy)
            mvwaddnstr(w, (int)o->y - dy, (int)o->x, "###", OB_WIDTH);
    }
}
